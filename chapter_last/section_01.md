# 延伸阅读-二进制存储

---

首先明白一点，计算机里只能保存0或1，即二进制的形式，无论是整数、浮点数、字符、还是图片，到了计算机中，都得保存为0或1.

## 1. 整数的二进制存储

整数指byte, short, int, long这四种类型。以byte为例，它长度为一个字节，即8位\(bit\)，最多能够保存8个0或者1

![](/chapter_last/1.png)

上图表示这一个byte中保存了8个1，它代表什么数字呢？  
先看低7位，它们每一位的1换算成十进制数就是2^n 次方。

例如：

第0位的1换算成十进制就是 2^0 = 1

第1位的1换算成十进制就是 2^1 = 2

第2位的1换算成十进制就是 2^2 = 4

第3位的1换算成十进制就是 2^3 = 8

... ...

简单点理解高位的一个1就是稍低一位的两倍：100 是10的两倍（一个顶2个），就像十进制的100 相比10 来说，第2位的1是第1位的1的10倍（一个顶10个）

初步结论是，低7位是：

```
1111111 = 2^6+2^5+2^4+2^3+2^2+2^1+2^0=127
```

最高位的1，很多教程中都解释为符号位：1代表负数、0代表正数，这么理解可以。  
但我可以给一个更好的解释，最高位的1仍可以按上述规则来换算，刚才的例子中，它就是：

```
2^7 = 128
```

但要记得给它加个负号，结果是 -128

最终结论是：

```
最高位 + 低7位 = -128 + 127 = -1
```

要再深究的话，需要看看微机原理，CPU做运算时只有加法器，没有什么减法器，之所以这么设计最高位，是为了方便加法计算，举个例子：

```
  1000 0001 (十进制 -127)
  0111 1111 (十进制 127)
+ -------------------------
  0000 0000 (十进制 0 )
```

第一个数的低7位是1，第二个数的低7位是127，加起来是128和最高位的-128 正好抵消成0（溢出）

> 注意：前提是，运算的结果不能超过其存储范围（-128～127）

## 2. 负数存储的艺术
以字节为例：

首先介绍一个特殊的数字，前面已经见过127 二进制表示为 0111 1111.

为什么说它特殊呢？考虑几个7位二进制(127以内)的正整数求和，请看下面几个例子：

| a | b | 和 | 备注 |
| --- | --- | --- | --- |
| 000 0000 | 111 1111  | 111 1111 | 0 + 127 = 127 |
| 111 0000 | 000 1111  | 111 1111 | 112 + 15 = 127 |
| 101 0000 | 010 1111  | 111 1111 | 80 + 47 = 127 |
| ... | ...  | 111 1111 | ... + ... = 127 |

发现规律：只要它们最后的和为127，a和b的关系恰巧是`逐位取反`，以后a和b可以称对方为`反码`。这个挺好理解，127就是二进制的7个1，把这7个1随便组合来，组合去。
> 注意：a和b的十进制是多少其实并不重要

好，下面我想存储一个-15，如何存储避免减法运算呢？

```
- 15 = (-128+128) -15
     = (-128) + (128-15)
     = (-128) + (1+127-15)
     = (-128) + (1+15的反码)
``` 

下面我们不用做减法运算了，记得-128是 1000 0000 喔，合在一起，结果是：

```
  1000 0000  (-128)
  0000 0001  (1)
  0111 0000  (15的反码112)
+ -------------------------
  1111 0001  (-15)
```
最后的结果，计算机教程里把它叫做15的补码：`所有位取反+1`，结论比我的简单，但失去推导过程的话，比较难理解。


## 3. 浮点数的二进制存储

浮点数相对比较复杂：它由三部分组成：符号位，指数位，小数部分

例如对于float来讲：

![](/chapter_last/2.png)

符号位1位，以s表示，取值 \(-1\)^s

指数部分8位，以E表示，取值 -126~127，存储时在真正指数值的基础上+127

小数部分23位，以M表示，1&lt;=M&lt;2 采用科学计数法表示的二进制小数，因为M总是1.xxxx，所以保存时只存储小数部分，例如1.01只存储小数部分的01，整数部分读取时再加上，这样的目的可以多存储一位数组，即24位。

比如：9.5 的二进制为1001.1，采用科学计数法后为1.0011 \* 2^3

符号位和小数比较简单

指数部分存储规则：

```
  0000 0011 (十进制3)
  0111 1111 (十进制127)
+ -------------------------
  1000 0010 (十进制-126)
```

最终的存储格式为：

| 符号位 | 指数 | 小数 |
| --- | --- | --- |
| 0 | 1000 0010 | 001 1000 0000 0000 0000 0000 |

## 4. 浮点数精度问题

以小数部分的精度为例：刚才分析过小数部分能够表示的最大范围是24位，换算成十进制就是2^24=16777216

看看这个数值前后在存储时有什么问题：

| 实际数	float表示的浮点数 | 二进制存储 |
| --- | --- |
|16777211	1.6777211E7|	0100 1011 0111 1111 1111 1111 1111 1011 |
|16777212	1.6777212E7|	0100 1011 0111 1111 1111 1111 1111 1100 |
|16777213	1.6777213E7|	0100 1011 0111 1111 1111 1111 1111 1101 |
|16777214	1.6777214E7|	0100 1011 0111 1111 1111 1111 1111 1110 |
|16777215	1.6777215E7|	0100 1011 0111 1111 1111 1111 1111 1111 |
|16777216	1.6777216E7|	0100 1011 1000 0000 0000 0000 0000 0000 |
|16777217	1.6777216E7|	0100 1011 1000 0000 0000 0000 0000 0000 |
|16777218	1.6777218E7|	0100 1011 1000 0000 0000 0000 0000 0001 |
|16777219	1.677722E7|	0100 1011 1000 0000 0000 0000 0000 0010 |
|16777220	1.677722E7|	0100 1011 1000 0000 0000 0000 0000 0010 |
|16777221	1.677722E7|	0100 1011 1000 0000 0000 0000 0000 0010 |

可以看到16777215 之前的数据没有问题，注意到 16777216 与 16777217在存储时值已经相同；类似的，16777219、16777220、16777221三个数在存储时也是相同的。

换句话说，这时候计算机已经无法区分它们了，可以验证：

```
System.out.println(16777216f == 16777217f); // true
System.out.println(16777220f == 16777219f); // true
System.out.println(16777220f == 16777221f); // true
```

结论：float的小数部分只能够精确到2^23，也就是小于16777216 的数字能够保证小数点后7位都是有效的，大于等于它的数只能保证小数点后6位是有效的。

---



