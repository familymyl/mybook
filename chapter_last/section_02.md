# 延伸阅读-浮点数二进制存储

---

## 1. 浮点数的二进制存储

浮点数相对比较复杂：它由三部分组成：符号位，指数位，小数部分

例如对于float来讲：

![](/chapter_last/2.png)

符号位1位，以s表示，取值 \(-1\)^s

指数部分8位，以E表示，取值 -126~127，存储时在真正指数值的基础上+127

小数部分23位，以M表示，1&lt;=M&lt;2 采用科学计数法表示的二进制小数，因为M总是1.xxxx，所以保存时只存储小数部分，例如1.01只存储小数部分的01，整数部分读取时再加上，这样的目的可以多存储一位数组，即24位。

比如：9.5 的二进制为1001.1，采用科学计数法后为1.0011 \* 2^3

符号位和小数比较简单

指数部分存储规则：

```
  0000 0011 (十进制3)
  0111 1111 (十进制127)
+ -------------------------
  1000 0010 (十进制-126)
```

最终的存储格式为：

| 符号位 | 指数 | 小数 |
| --- | --- | --- |
| 0 | 1000 0010 | 001 1000 0000 0000 0000 0000 |

## 2. 浮点数精度问题

以小数部分的精度为例：刚才分析过小数部分能够表示的最大范围是24位，换算成十进制就是2^24=16777216

看看这个数值前后在存储时有什么问题：

| 实际数	float表示的浮点数 | 二进制存储 |
| --- | --- |
|16777211	1.6777211E7|	0100 1011 0111 1111 1111 1111 1111 1011 |
|16777212	1.6777212E7|	0100 1011 0111 1111 1111 1111 1111 1100 |
|16777213	1.6777213E7|	0100 1011 0111 1111 1111 1111 1111 1101 |
|16777214	1.6777214E7|	0100 1011 0111 1111 1111 1111 1111 1110 |
|16777215	1.6777215E7|	0100 1011 0111 1111 1111 1111 1111 1111 |
|16777216	1.6777216E7|	0100 1011 1000 0000 0000 0000 0000 0000 |
|16777217	1.6777216E7|	0100 1011 1000 0000 0000 0000 0000 0000 |
|16777218	1.6777218E7|	0100 1011 1000 0000 0000 0000 0000 0001 |
|16777219	1.677722E7|	0100 1011 1000 0000 0000 0000 0000 0010 |
|16777220	1.677722E7|	0100 1011 1000 0000 0000 0000 0000 0010 |
|16777221	1.677722E7|	0100 1011 1000 0000 0000 0000 0000 0010 |

可以看到16777215 之前的数据没有问题，注意到 16777216 与 16777217在存储时值已经相同；类似的，16777219、16777220、16777221三个数在存储时也是相同的。

换句话说，这时候计算机已经无法区分它们了，可以验证：

```
System.out.println(16777216f == 16777217f); // true
System.out.println(16777220f == 16777219f); // true
System.out.println(16777220f == 16777221f); // true
```

结论：float的小数部分只能够精确到2^23，也就是小于16777216 的数字能够保证小数点后7位都是有效的，大于等于它的数只能保证小数点后6位是有效的。

---



